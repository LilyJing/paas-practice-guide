## 运行时框架的选择

按照上一章所描述，必须选择一个适合大数据的运行时框架。我们不可能选择一个语言级的沙盒，也不能选择一个工具来实现。最适合的方式现在看来就是容器，特别以Docker为代表的容器。

但我们仍需要为其选择一个框架，来将打包了开发者代码的容器托管起来。这个框架需要很好的支持内部服务发现、维持可用性、支持外部路由，并提供足够底层的面向开发者服务的接口。

按照第三部分的分析，为了更好地支持微服务，降低对用户代码的侵入，我们选择Kubernetes作为托管运行时环境的框架。

## 后端支持服务框架的选择

按照上一章所描述，我们需要有一个标准化的框架来支持不同的后端服务的插拔。

开发者在申请后端服务实例后，我们需要一个机制将这些信息让运行时环境中的代码感知到。在Kubernetes中，我们可以通过两种机制来实现：

* **环境变量**。通过Deployment的手段来新增或修改它管理的Replica config的环境变量。通过这样的机制将后端支持服务实例的信息传进去。
* **External Service**。利用Service的机制建立不关联Laber Selector的Service，自行添加Endpoints对象，将外部的地址和端口添加进去。这种方式不够灵活，且无法传递用户名、密码等相关信息。
* **DNS**。修改DNS的设置，这种方式与External Service机制类似，但DNS有延迟时间。
* **Config Map**。通过Kubernetes的资源对象Config Map，可以把配置文件打包并传递到Deployment对象中，供其试用。这种方式可以传递更多的信息，也比环境变量安全。通过Secret的方式还可以传递加密的配置文件。试用范围更广。

按照上面的比较，我们会选择环境变量和Config Map两种方式综合试用来将后端服务实例传递进去。
对于后端支持服务的管理框架，我们选择Cloud Foundry的Service Broker机制。因为Cloud Foundry是比较成熟的PaaS框架，其Service Broker结构设计合理，可扩展性强。

```
Service Broker
```

通过Service Broker的协议。每一个后端支持服务的管理者都

## 其他工具的选择

### 代码库

### 镜像库

### 持续集成

### 监控

### 日志管理

