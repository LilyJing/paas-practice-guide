## 原有PaaS的局限

自2008年PaaS 1.0被Google使用GAE定义后，PaaS一直难以成为云计算模式中的主流选择，原因无非如下：

* **PaaS并不适用公有云的商业模式**。PaaS处于云计算三种模式的中间，因此既需要提供便利，又需要给使用者自由。最早的GAE和SAE通过语言级的沙盒来实现，但在资源隔离和安全防护方面都不尽人意。后来虽然采用了容器技术，但容器本质上仍旧是操作系统级别之上的虚拟化，隔离程度仍然不够理想。所以PaaS普遍存在租户之间的隔离只能大略实现，租户之间的安全性无法得到彻底保障的情况。将PaaS应用在公有云环境中就会遇到这样那样的问题，从这个意义上讲AWS推出的Beanstalk和Lamda倒是比较比较适合的一种PaaS实现方式，因为它们的底层隔离仍然是虚拟机。PaaS特别适合私有云的模式，因为私有云对隔离要求得并不那么高，所有的使用者都是可控的使用者，而PaaS给开发者带来的便利有效降低了每个开发者需要重复进行的工作。因此Cloud Foundry这个私有PaaS管理平台在国内基本成为了PaaS的代名词。
* **PaaS在技术上提供的便利程度不足**。原有PaaS托管开发者提交的代码的时候的运行环境和开发者本地的开发测试环境无法达到完全一样，不仅对语言有所限制，也无法自由使用操作系统的网络端口、IPC资源等。同时在PaaS中为开发者提供的数据库等后端服务也可能和本地环境的不一致，且难以像本地环境一样去访问。在程序出现问题后，调试起来也比本地困难。再加上早期的PaaS不提供命令行的方式，只能在页面上进行操作，效率进一步降低。因此原有PaaS给开发者，特别是开发新的程序的开发者而言，带来的便利程度相比需要付出的努力来说不显著。甚至对于没有经验的使用者来说，带来的问题更多，学习曲线相对陡峭。

受上述两个根本因素的影响，似乎PaaS很难走出自己的局限，2010年HerorKu被收购后，业界对于PaaS是否是一个在商业上成立的云计算模式产生了怀疑，而这一切直到2014年Docker正式出现在大众视野中导致容器技术大火后才得到了改变。

## 什么是容器

容器，从字面的意思上理解就是装东西的东西。研究什么装、什么被装固然很有意思，但研究为啥有容器也很有意思。

古代容器中最著名的就是青铜大鼎，历史博物馆必放之物。古老的容器解决了盛放各种物品的问题，同时也建立了量化的标准，比如“九鼎”。现在容器中最著名的就要数集装箱了（其在英文中也是container），集装箱没有什么技术含量，无非就是建立了一个运输的标准，但它完全改变了船运业，进而改变了所有的运输业，甚至改变了生产和消费方式，给大家带来了全球化和全球供应链。具体可以参看《集装箱改变世界》这本书。

有了集装箱，货物可以封装在其中，然后标准化地在不同的轮船、火车、卡车上进行运输。运输的效率提高了，成本降低了，有很多以前无法享受全球化的商品（比如水果）就可以在全球流通了。

在软件产业中也有同样的现象。我们有各种各样的软件，例如重型的传统数据库、新型的并行数据库、易扩展的Web应用、CPU密集型的计算应用等，这些软件需要运行在各种主机、各种云平台和各种操作系统中。多对多的关系令人感到抓狂，为什么不能把这些不同的应用都装到容器里面然后运行在不同的主机、环境和操作系统之中？这就是容器技术在软件产业中的拓展。

以Docker为代表的容器技术，就像运输业的集装箱一样，实现了Build（按照标准把货物装入集装箱）、Ship（把集装箱运行到任何地方）、Run（通过多种交通工具来运输集装箱）。

## Docker成为了容器的事实标准

容器技术由来已久。2001年Namespace技术就开始提交到Linux内核，为进程之间提供了六个方面的隔离；2004年Google开始在集群中使用Borg来进行编排；2007年，google提交了一个重要的限制进程组所使用资源的组件cgroup到linux内核之中；2008年，Redhat发布了libvirt，作为第一个容器实现；2008年8月Linux社区推出了LXC方案；2009年，Twitter开始启动了Mesos项目；2013年是一个非常重要的时间节点，Docker横空出世，容器虚拟化有了统一的平台，到本年底docker迅速发展到了0.7版本，开始支持层叠文件系统；到了2014年6月，Google发布了基于Docker的编排平台Kubernetes，给容器技术添加了一把火。

所有的容器技术都离不开cgroup和namespaces技术，但是这两项技术早于Docker很多年出现，且在libvirt和LXC两个容器项目中都有使用，但为什么Docker这么火（Docker最早的runtime其实就是LXC）？ 成为了容器的事实标准？可能会是因为如下几个原因：

* Docker明确区分了容器和镜像，并定义了镜像标准，这个标准是其能实现Build Ship and Run的关键。

* 镜像采用了层叠文件系统，这样不但降低了Ship过程中网络数据的传输量，同时也大大降低了使用同样基础镜像的容器镜像的大小，使得“一个进程一个容器的封装形式”成为可能。

* 由于Docker有统一的镜像格式，而且这种镜像格式采用了层叠文件系统，于是Docker成功建立了一个以Dockerhub为梯子的容器镜像周边生态。我们需要某个程序的时候不再需要下载和编译，仅仅Docker run 就可以了，把互联网当成自己的程序库。


Docker第一次赋予了开发和运维人员真正的一次编译、多次运行的能力，而且这些运行是可以跨域不同的环境（开发、测试、预上线和生产）、不同的时间、不同的地域、不同的公司。

镜像标准就是Docker赋予容器技术的“梯子”，它使得技术人员的成果可以方便地建立在自己或者他人之前的工作基础之上，再困难的事情，有了一层一层的梯子搭起来，终究会解决的。

随着计算机硬件发展的不同时代，曾经有不同的“梯子”存在。在硬件层面，Ghost镜像曾经就是其中一种，但它没有解决大量硬件依赖的问题；虚拟机时代，虚拟机镜像，比如Vagrant Image也是一种，但这些文件都很大，而且并没有形成通用的虚拟机镜像标准；Java等语言也提供了语言级虚拟机 JVM，但其因为语言相关而不够灵活。所以说在容器级别实现的这个标准粒度和标准化层度都非常合适。

我们经常看到容器和虚拟化的比较，但是其实更加合适的是容器和进程的比较，因为容器实际上就是在进程之上加入了各种限制而已。它是一个操作系统之上的虚拟化方案，因此更加轻量级，对资源的损耗也更加少。

## Docker带来了PaaS的新生

由于Docker定义了容器镜像的标准，就像集装箱一样定义了运输的标准然后改变了运输业一样，Docker改变了软件交付这个环节。任何组件、应用或者微服务再也不需要以二进制代码或源码的形式进行交付，不用遇到不同的操作系统、不同的类库、不同编译器、不同的外部依赖的问题。可以方便地迁移到任何地方。不仅在开发、测试、预上线和生产环境中迁移；也可以在不同的项目中被方便地重复使用；可以在不同的公司和地点被多次地部署。一个命令就解决了之前需要低水平重复的很多工作。

Build Ship and Run , Any app, Anywhere。这个Docker的商业口号非常直观，也解释了它如何给PaaS带来了新生。

首先它部分解决了PaaS应用于公有云模式的问题。Docker相比之前的容器技术预留了比较好的隔离方式。在资源限额方面，它继承自cgroup，因此可以对CPU和内存等进行较好的资源限制，对网络和IO的限制也正在进行中；在租户隔离方面，它继承自namespace，因此应用可有自己的网络栈，开自己喜欢的任意端口，所有人在不同的namespace中，互相看不见，这降低了对开发者的限制。

其次它设立的镜像和容器标准实现了Run Any APP at Anywhere的特点，一次打包，多次运行。因此开发者只要在本地调试成功，上传云环境一定运行起来和本地是一模一样的。这极大解决了开发者开发程序过程中PaaS带来的困扰。因此PaaS带来的便利程度得到了最好的发挥。

Docker出现后，一种以Docker容器为托管对象的PaaS模式出现了，它们被特别地称之为CaaS（Container as a Service）。而各大IaaS提供商，比如AWS、微软Azure、阿里云均开始提供CaaS服务。Cloud Foundry的V3版本也开始支持Docker镜像运行在其中。Docker公司收购了Tutum后也推出了自己的CaaS服务——Docker Cloud

－－－－－－－

由于解决了交付的难题，Docker给DevOps带来了新生。自从Docker出现后，DevOps变得火热，之前使用vagrant、ansible或saltstack实现的DevOps流程和工具终究不如Docker那样彻底。从此开发人员和运维人员沟通的基础变成了Docker Image和它们的编排文件。

同样的，Docker也改变了目前的软件开发模式，持续集成（CI）和持续交付（CD）都变得非常容易。不但老牌的Jenkins工具率先支持了Docker来进行CI和CD，更是有Drone这样新一代的工具原生就支持Docker，不但自己是以Docker方式运行，所有的插件也是以Docker的方式运行。 CI\/CD成了谈Docker的时候必谈的一个应用。

Docker带来的最大改变恐怕还是要在软件架构方面，它使得我们可以负担得起微服务的创新架构。微服务架构带来了开发效率和运行效率的提升，但如果缺少适当的工具就会有很高的运维成本，Docker改变了这一切。开发者可以不用使用Spring Cloud或Dubbo这样的Java语言级框架；并且Docker接管了资源控制、安全隔离、网络可达、日志、运行监控、健康检查等复杂、琐碎且重复的事宜。Docker降低了我们应用微服务的难度，使得架构师可以将功能拆小，小意味着简单、可扩展性强、可靠性高、可以自由组合。

但是顺带说一句，如果只是几台机器的小规模部署系统，仅用Docker在传统工具下自动部署就可以，但是一个大型的、多租户的系统，还是需要一个完善的容器编排框架，并将所有容器难以承担的有状态后端服务进行管理，那就是PaaS。PaaS使得微服务的部署不用关心物理集群、可以跨集群进行访问、微服务可以形成组合并有效隔离、集中收集日志、维持全局微服务状态啊，PaaS还提供了服务注册和发现的框架，使得应用不需要自己实现。当然PaaS还集中管理了持久化卷以及诸如Mysql之类的Backing Service，使得微服务的开发和运维工作进一步简化。

