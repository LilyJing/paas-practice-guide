PaaS实现了应用开发者和平台维护者之间的分工，应用开发者可以提交代码给PaaS平台，这些代码的运行将按照应用开发者的预期来进行。但例如高可用、扩展性的实现部分每份代码都可能不一样，如果保持原样托管到PaaS中，PaaS云平台最多只能将这些代码运行起来，在遇到故障或需要扩展的时候不知道应该如何处理。

要想尽可能多地由云平台提供便利性，而减少应用开发者需要书写的代码量，这就要求托管到PaaS平台上的代码需要遵守一些规则。但也需要考虑到传统PaaS的缺陷就是对开发者提出了较多的“要求”。所以我们必须在提供便利和提出要求之间找到一个折衷。

有了Docker作为运行时环境，我们已经可以对开发者使用的语言、基础操作系统、库文件和依赖的第三方组件不用提出要求。但对于高可用和扩展性的实现部分，仍需要规定一些代码风格。主要的目的是为了尽可能地实现代码的“无状态”化。

[Heroku](http://www.heroku.com/)是业内知名的PaaS云平台，从对外提供服务以来，他们已经有上百万应用的托管和运营经验。基于这些积累，其创始人Adam Wiggins在2012年发布了一个“十二因子（The Twelve-Factor App）”的规范。参见附录A。Adam Wiggins对应用开发者提出了十二项建议，其实质就是为了实现无状态，如果符合这些规范建议，那么应用在HeroKu等PaaS云平台上将会非常容易，也能充分将平台的功能充分发挥出来。

Docker出现后，更加强了十二因子的开发模式的普及。这是因为Docker能非常好地支持无状态应用的部署和托管。针对复杂应用和多节点，Google开源了Kubernetes作为编排引擎。为了推广运行在Docker和Kubernetes等PaaS平台中应用的最佳实践，2015年Google联合其他20家公司宣布成立了开源组织Cloud Native Computing Foundation（CNCF）。CNCF也将隶属于Linux基金会管理，初始包括21家厂商：AT&T、Box、Cisco、Cloud Foundry Foundation、CoreOS、Cycle Computing、Docker、eBay、Goldman Sachs、Google、Huawei、IBM、Intel、Joyent、Kismatic、Mesosphere、Red Hat、Switch SUPERNAP、Twitter、Univa、VMware and Weaveworks。

Cloud-Native被翻译为云原生。它要求应用开发者必须改变编码方式，在开发者和运行应用的基础设施之间建立一种新的契约。十二因子就是一个很好的契约。

在大数据PaaS平台的项目中，我们对应用开发者需要提出如下契约：

* 应用和后端服务分离





后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息\/队列系统（RabbitMQ，Beanstalkd），以及缓存系统（Memcached）。





因为后端服务通常是共用的，且每个地方的资源有所区别，所以未来要实现和本地定制化内容的解耦，必须**将应用逻辑和后端服务分离**。**无论是本地后端服务还是远程后端服务（例如互联网OPEN API），我们都可以将其视为资源**，通过一个 url 或是其他存储在配置中的服务定位\/服务证书来获取数据，这样应用可以部署在多个地方而不需要进行任何代码改动，同时也可以方便地将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。





 





 





 





 






 
 
  
  
  
  
  
  
  
  
  
  
  
  
 
 
 

 






## 1.2    应用内部的解耦





为了实现应用的松耦合、支持快速迭代，应用本身的规模也需要进行拆分。拆分的原则可能包括：技术栈不一样、迭代周期不一样和扩展规模的不一样。将应用按照“微服务”的方式进行解耦，并通过服务发现的方式进行通信，能享受以下好处：





l  降低了复杂度：由于解耦，单个服务开发难度降低，因此系统整体复杂度降低了。





l  使用不同的技术栈：每个开发团队可能有自己最熟悉的技能，每个模块可能有最适合的后端服务，如果解耦则可以灵活选择。





l  可扩展性强：除了每个“服务”均可以自行扩展到相应规模以外，由于解耦，使得某个服务的迭代不会影响其他服务。





l  可以更好支持前端：对于前端JS框架、H5的移动页面、原生移动客户端，微服务均可以统一支撑。





微服务架构示例如下：






 






Docker是很好的微服务封装的标准。





解耦的各个微服务之间通过REST风格的API进行互相通信，使用与后端服务同样的服务发现框架进行服务的注册、查找和路由。





## 1.3    代码和配置分离





通常，应用的配置在不同部署\(预发布、生产环境、开发环境等等\)间会有很大差异。这些配置可能包括：





l  数据库，Memcached，以及其他后端服务的配置





l  第三方服务的证书，如 Amazon S3、Twitter等





l  每份部署特有的配置，如域名等





有些应用在代码中使用常量保存配置，这就使得应用的部署需要修改代码。为了实现一份基准代码、多这个部署，**我们需要实现在代码库中代码文件和配置的分离。**





判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。





**我们推荐将应用的配置存储于环境变量中（ env
vars, env ）**。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们提交代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。





**将配置存储在环境变量中，还提供了一个简单的机制以便应用框架为应用传递信息**。





## 1.4    弹性扩展和高可用





避免任何单点故障，任何组件均可以运行一到多个实例，其他调用通过服务发现来访问这些实例，实例可以分别承担负载。





要实现这个需求，要求组件必须无状态且无共享。任何需要持久化的数据都要存储在后端服务内，比如数据库。





如果组件使用内存区域或磁盘空间作为缓存，应不能考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为将来的请求多半会由其他组件来服务。即使在只有一个组件，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。





同样，不应依赖 “粘性 session”\( 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程\)。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。





新的组件实例启动后应当主动向服务发现功能进行注册，注册的内容包括IP地址和端口等。组件实例失效后应当及时从服务发现的列表中移除，可以通过组件向zookeeper或etcd等定期更新带TTL的节点，并由confd等进程watch并修改服务发现的配置文件实现。





## 1.5   
健壮性设计





应用的进程应该可以瞬间开启或停止。
这有利于快速、弹性的伸缩应用，迅速部署变化的代码或配置 ，稳健的部署应用。





进程应当追求最小启动时间。理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的发布以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。





**进程一旦接收终止信号（SIGTERM）就会优雅的终止**。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短\(不会超过几秒钟\)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。





对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。
Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，**任务都应该可重复执行**， 这主要由将结果包装进事务或是使重复操作**幂等**来实现。



进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，应用都应该可以设计能够应对意外的、不优雅的终结。





